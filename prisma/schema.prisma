generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  type                String?
  provider            String?
  provider_account_id String?
  refresh_token       String?
  access_token        String?
  expires_at          DateTime?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?

  @@unique([provider, provider_account_id])
  @@map("accounts")
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  approved_at  DateTime?
  availability String?

  email      String? @unique
  username   String? @unique
  name       String? @db.VarChar(255)
  first_name String? @db.VarChar(255)
  last_name  String? @db.VarChar(255)
  password   String? @db.VarChar(255)
  domain     String? @unique
  avatar     String?

  phone_number  String?
  country       String?
  state         String?
  city          String?
  address       String?
  zip_code      String?
  gender        String?
  date_of_birth DateTime? @db.Date

  // billing id. e.g. stripe customer id
  billing_id String?

  type              String?   @default("user")
  email_verified_at DateTime?

  is_two_factor_enabled Int?    @default(0)
  two_factor_secret     String? // secret key for two factor authentication

  accounts                  Account[]
  creator_conversations     Conversation[] @relation("creator")
  participant_conversations Conversation[] @relation("participant")
  receiver_messages         Message[]      @relation("receiver")
  sender_messages           Message[]      @relation("sender")
  receiver_notifications    Notification[] @relation("receiver")
  sender_notifications      Notification[] @relation("sender")

  user_payment_methods UserPaymentMethod[]
  user_settings        UserSetting[]
  ucodes               Ucode[]
  roles                Role[]
  role_users           RoleUser[]
  payment_transactions PaymentTransaction[]
  age                  Int?
  bio                  String?
  skills               String[] // Array of skill strings
  jobs                 Job[]

  helper_offers    CounterOffer[]  @relation("UserHelperOffers")
  assigned_jobs    Job[]           @relation("AssignedHelper")
  reviewer_reviews Review[]        @relation("ReviewerReviews")
  reviewee_reviews Review[]        @relation("RevieweeReviews")

  stripe_connect_account_id String?       
  stripe_account_status String?    
  stripe_payouts_enabled      Boolean? @default(false)
  stripe_onboarding_completed Boolean? @default(false)
  
  // Location coordinates for distance calculation
  latitude  Float? // User's latitude
  longitude Float? // User's longitude
  
  // Helper notification preferences
  notification_preferences Json? // Store helper's job notification settings
  max_distance_km Int? @default(20) // Maximum distance for job notifications (default 20km)
  min_job_price Decimal? // Minimum job price to get notified
  max_job_price Decimal? // Maximum job price to get notified
  preferred_categories String[] // Categories helper wants to be notified about
  
  // Firebase push notification tokens
  device_tokens String[] // Array of Firebase device tokens for push notifications
  
  // User cards
  cards UserCard[]
  @@map("users")
}

model Ucode {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())
  status     Int?     @default(1) @db.SmallInt

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  token      String?
  email      String?
  expired_at DateTime?

  @@map("ucodes")
}

model Role {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  title  String?
  name   String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  permission_roles PermissionRole[]
  role_users       RoleUser[]
  permissions      Permission[]     @relation("PermissionToRole")

  @@map("roles")
}

model Permission {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  title      String?
  action     String?
  subject    String?
  conditions String?
  fields     String?

  permission_roles PermissionRole[]
  roles            Role[]           @relation("PermissionToRole")

  @@map("permissions")
}

model PermissionRole {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  permission_id String
  permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@id([permission_id, role_id])
  @@map("permission_roles")
}

model RoleUser {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([role_id, user_id])
  @@map("role_users")
}

// this table stores notification event
model NotificationEvent {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  read_at DateTime?

  status Int? @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?

  @@map("notifications")
}

model UserPaymentMethod {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  payment_method_id String?
  checkout_id       String?

  @@map("user_payment_methods")
}

model PaymentTransaction {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  store_id String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  order_id         String?
  type             String?  @default("order")
  withdraw_via     String?  @default("wallet")
  provider         String?
  reference_number String?
  status           String?  @default("pending")
  raw_status       String?
  amount           Decimal?
  currency         String?
  paid_amount      Decimal?
  paid_currency    String?

  @@map("payment_transactions")
}

// ---------Start Chat schema---------

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
}

enum jobType {
  URGENT
  ANYTIME
}

enum PaymentType {
  HOURLY
  FIXED
}

enum JobCategory {
  CLEANING
  PLUMBING
  ELECTRICAL
  HANDYMAN
  PAINTING
  GARDENING
  MOVING
  DELIVERY
  PET_CARE
  TUTORING
  TECHNOLOGY
  PHOTOGRAPHY
  EVENT_PLANNING
  BEAUTY_WELLNESS
  FITNESS
  SECURITY
  CARPENTRY
  ROOFING
  HVAC
  LANDSCAPING
  CAR_SERVICES
  HOUSE_SITTING
  ERRANDS
  ASSEMBLY
  PERSONAL_CARE
  TRANSPORTATION
  OTHER
}

// message is used for conversation
model Message {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status MessageStatus? @default(PENDING)

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  conversation_id String?
  conversation    Conversation? @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  attachment_id String?
  attachment    Attachment? @relation(fields: [attachment_id], references: [id])

  message String?

  @@map("messages")
}

// this table stores attachment of message
model Attachment {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name     String?
  type     String?
  size     Int?
  file     String?
  file_alt String?

  messages Message[]

  @@map("attachments")
}

// this table stores conversation
model Conversation {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  creator_id String?
  creator    User?   @relation("creator", fields: [creator_id], references: [id])

  participant_id String?
  participant    User?   @relation("participant", fields: [participant_id], references: [id])

  messages Message[]

  @@map("conversations")
}

// ---------End Chat schema---------

model Faq {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  question   String?
  answer     String?

  @@map("faqs")
}

model Contact {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  first_name   String?
  last_name    String?
  email        String?
  phone_number String?
  message      String?

  @@map("contacts")
}

model SocialMedia {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  name       String?
  url        String?
  icon       String?

  @@map("social_medias")
}

model WebsiteInfo {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name                String?
  phone_number        String?
  email               String?
  address             String?
  logo                String?
  favicon             String?
  copyright           String?
  cancellation_policy String?

  @@map("website_infos")
}

model Setting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  category      String?
  label         String?
  description   String?
  key           String? @unique
  default_value String?

  user_settings UserSetting[]

  @@map("settings")
}

model UserSetting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  setting_id String?
  setting    Setting? @relation(fields: [setting_id], references: [id])

  value String?

  @@map("user_settings")
}

// Job posting models
model Job {
  id              String             @id @default(cuid())
  created_at      DateTime           @default(now())
  updated_at      DateTime           @default(now())
  deleted_at      DateTime?
  status          Int?               @default(1) @db.SmallInt
  job_status      String?            @default("posted") // posted, counter_offer, confirmed, ongoing, completed, paid
  title           String?
  category        JobCategory?
  date_and_time   DateTime? 
  price           Decimal? // Original price set by user
  final_price     Decimal? // Price after counter offer accepted
  payment_type    PaymentType?
         
  location        String?
  latitude        Float? // Job location latitude
  longitude       Float? // Job location longitude
  description     String?            @db.Text
  job_type    jobType?       @default(ANYTIME) // Urgency type: FIXED or ANYTIME
  urgent_note     String?            @db.Text // Urgent note for urgent jobs
  
  // Job scheduling
  start_time      DateTime? // When job should start
  end_time        DateTime? // When job should end
  estimated_time  String?   // Auto-calculated from start_time and end_time
  
  // Time tracking for hourly jobs
  actual_start_time DateTime? // When helper actually started the job
  actual_end_time   DateTime? // When job was actually completed
  actual_hours      Decimal?  // Calculated actual hours worked
  hourly_rate       Decimal?  // Rate per hour for hourly jobs
  estimated_hours   Decimal?  // Calculated from estimated_time
  
  // Extra time request system
  extra_time_requested    Decimal?  // Extra time requested by helper (in hours)
  extra_time_approved     Boolean?  // Whether client approved the extra time
  extra_time_requested_at DateTime? // When extra time was requested
  extra_time_approved_at  DateTime? // When extra time was approved/rejected
  total_approved_hours    Decimal?  // Original estimated + approved extra time
  requirements    JobRequirement[]
  notes           JobNote[] //only be enabled if user selects the job type as urgent
  photos          String?
  user_id         String?
  user            User?              @relation(fields: [user_id], references: [id])
  counter_offers  CounterOffer[]     @relation("JobCounterOffers")
  
  // For counter offer acceptance
  accepted_counter_offer_id String?  // ID of the accepted counter offer
  accepted_counter_offer    CounterOffer? @relation("AcceptedCounterOffer", fields: [accepted_counter_offer_id], references: [id])
  
  // For direct job acceptance (optional)
  assigned_helper_id String?  // Direct helper assignment
  assigned_helper    User?    @relation("AssignedHelper", fields: [assigned_helper_id], references: [id])
  
  reviews         Review[]
  status_history  JobStatusHistory[]

  @@map("jobs")
}

model JobRequirement {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  title       String?
  description String? @db.Text

  job_id String?
  job    Job?    @relation(fields: [job_id], references: [id], onDelete: Cascade)

  @@map("job_requirements")
}

model JobNote {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  title       String?
  description String? @db.Text

  job_id String?
  job    Job?    @relation(fields: [job_id], references: [id], onDelete: Cascade)

  @@map("job_notes")
}

model CounterOffer {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  amount Decimal
  type   String
  note   String?

  job_id String
  job    Job    @relation("JobCounterOffers", fields: [job_id], references: [id])

  helper_id String
  helper    User   @relation("UserHelperOffers", fields: [helper_id], references: [id])

  // Relation for accepted counter offers
  accepted_by_jobs Job[] @relation("AcceptedCounterOffer")

  @@map("counter_offers")
}


model Review {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  rating  Int? // 1-5 star rating
  comment String? @db.Text // Review text/note

  // Who wrote the review
  reviewer_id String?
  reviewer    User?   @relation("ReviewerReviews", fields: [reviewer_id], references: [id])

  // Who is being reviewed
  reviewee_id String?
  reviewee    User?   @relation("RevieweeReviews", fields: [reviewee_id], references: [id])

  // Which job this review is for
  job_id String?
  job    Job?    @relation(fields: [job_id], references: [id], onDelete: Cascade)

  @@map("reviews")
}

model JobStatusHistory {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  job_id String
  job    Job    @relation(fields: [job_id], references: [id], onDelete: Cascade)

  // e.g. posted, counter_offer, confirmed, ongoing, completed, paid, cancelled
  status      String
  occurred_at DateTime @default(now())
  meta        Json?

  @@index([job_id, status])
  @@map("job_status_histories")
}

// this table stores example
// model Note {
//   id                String  @id @default(cuid())
//   created_at DateTime  @default(now())
//   updated_at DateTime  @default(now())
//   deleted_at DateTime?
//   status     Int?      @default(1) @db.SmallInt

//   title String?
//   body  String? @db.Text

//   tenant_id Int?
//   tenant    Organization? @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
//   @@map("posts")
// }

// User Card Management
model UserCard {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?
  status     Int?      @default(1) @db.SmallInt

  // Card details
  cardholder_name String
  card_number     String? // Encrypted card number (last 4 digits visible) - Optional for Stripe cards
  expiration_date String // Format: MM/YY
  cvv             String? // Encrypted CVV - Optional for Stripe cards
  card_type       String? // Visa, MasterCard, etc.
  last_four       String // Last 4 digits for display
  
  // Card status
  is_default      Boolean @default(false)
  is_expired      Boolean @default(false)
  
  // Stripe integration
  stripe_payment_method_id String? // Stripe payment method ID
  
  // User relationship
  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_cards")
}
